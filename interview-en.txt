Dear Henry,

Thank you again for your generosity and these wonderfully insightful questions. I truly appreciate that you've grasped the core philosophical points of Gura-lang.

Please find my answers below. I look forward to reading your article!

Best regards,
Yutaka Saito

---

1. What initially motivated you to create Gura-lang? Were you trying to solve a specific problem, or exploring a new idea in language design?

The initial motivation was my attempt to create a graph drawing application. I was familiar with and used well-known software like gnuplot, but I wanted a tool that could perform operations such as differentiation directly within the mathematical expression format.

I envisioned a simple scripting language capable of defining functions and managing variables. At this point, I considered defining an equation like y = sin(x) and plotting it. While the program could internally generate numerical values for x within an appropriate range and interval, calculating y and plotting, I realized that the language's versatility would be significantly enhanced if the argument x could accept multiple values (such as an array) and return the results, also as an array. This concept was the starting point for Implicit Mapping.

---

2. Gura-lang is described as an iteration-oriented language. Could you explain why you consider iteration such a central concept?

For processing a collection of data—be it numbers, strings, or structured data—many languages approach the task algorithmically using constructs like for or while.

However, by representing a data collection as an iterator data structure, this repetitive processing can be expressed far more simply. I believe this simplicity is highly effective in modern approaches like machine learning. When feeding large amounts of data into a computer in a format suitable for the learning objective, using iterators allows for a much more efficient and clean implementation of the overall process.

---

3. When you started developing Gura-lang, were you aware that similar ideas had appeared in languages like Icon or APL? How do you see Gura’s place in that lineage?

When I began developing Gura, I knew very little about programming languages beyond the approximately ten major ones. It was about a year into the development that I became aware that similar approaches—processing data collections like lists and arrays in a batch—existed in languages like Icon or APL.

Therefore, the ideas we refer to as "Implicit Mapping" and "Member Mapping" in Gura were, in my mind, entirely original and did not stem from any particular lineage.

Regarding the syntax of the language, I was conscious of TypeScript, as its syntax is similar to C++, which I use daily, and it felt very familiar to me. I also looked to Python for inspiration, particularly in the design of built-in functions and standard libraries.

I originally considered implementing features like Implicit Mapping by extending existing languages, as that would allow me to utilize existing library resources. However, I soon realized that this feature concerns the very core of function calls and could only be achieved by designing the language from the ground up. I anticipated the massive effort required, but the desire to realize my unique idea and the sheer interest in creating a new language drove me to start the development.

---

4. Gura-lang supports Implicit Mapping and Member Mapping. Could you explain how these mapping mechanisms (implicit and member mapping) affect performance, memory usage, or readability compared with explicit loops or comprehensions in other languages?

The use of these features automatically handles repetitive processing during normal function calls and operator notation, eliminating the need for explicit constructs like for loops. This offers a significant benefit in terms of readability and conciseness.

Another critical point is that the iterative processing is encapsulated within the iterator data structure. With explicit loop processing (using for, etc.), it is often difficult to track whether the process introduces side effects externally or is affected by external factors. However, by taking the form of an iterator, the relationship between the internal iterator processing and external processing becomes clearly defined. If the processing inside the iterator is isolated (e.g., generating results from a fixed data stream with no external dependencies), it becomes suitable for parallel processing, which would significantly contribute to performance.

Regarding memory efficiency, I don't believe this feature, by itself, necessarily guarantees improvement. Depending on the processing content, the need to store the data generated by the iteration in memory might actually increase consumption. However, looking at today's hardware environment, while CPU speeds are approaching their limits, available memory capacity is dramatically increasing. I believe the approach of leveraging large amounts of memory to enhance performance will continue to evolve and become more prominent.

---

5. Nearly a decade later, parallel and concurrent computing have become more accessible — even in scripting environments. How do you see this evolution today, and do you think languages like Gura-lang (or Gurax) are still well-positioned to leverage this paradigm?

As you mentioned, attempts to improve performance through parallelization, such as with GPUs and quantum computing, are thriving.

However, in most languages, programmers achieve parallel programming by explicitly creating multiple threads. Running multiple threads necessitates resource contention management, which makes the program excessively complex. This is frankly nonsensical; most programmers are not interested in running programs in parallel per se, but simply want to increase execution performance. The ideal scenario is being able to use the same programming approach as before, with the parallelization of the process being completely hidden from the programmer.

Implicit Mapping could be one solution to this challenge. By representing data as an iterator and applying Implicit Mapping, the operation appears to be a regular function call or arithmetic operation, but the script can automatically decide to process it in the background. That is, generating multiple iterators would automatically lead to parallel processing.

However, I personally have very little knowledge of parallel processing. Furthermore, the implementation itself would be incredibly difficult, likely exceeding what one person can solve. Therefore, what I have described above is currently a dream. Nevertheless, I am often strongly driven by the desire to realize it.

---

6. Have you considered extending Gura-lang (or Gurax) to interact with other ecosystems (for example, embedding it as a scripting language within other applications, similar to Lua)?

Since I initially developed it as a scripting language for a graph drawing application, embedding it into other applications has always been a consideration.

I previously worked at a hardware design company where I created a digital signal waveform drawing tool. I embedded Gura into that program to automate the drawing of pulse patterns via scripting, and it worked very well. This development process gave me confidence in Gura's utility for application embedding.

I am also considering its application in single-board microcontrollers. I am currently developing a platform called pico-jxgLABO that connects various hardware components to a Raspberry Pi Pico. There is a frequent need for a scripting language to control the hardware easily. Gura's parser is very simple, and since I built it alone, I understand all the processing details. If the memory management part could be adapted for a microcontroller, a MicroGura, similar to MicroPython for microcontrollers, might be possible.

---

7. You later began working on Gurax. Is it a successor to Gura-lang or a complete redesign? What are the main differences between the two?

Yes, Gurax is the successor to Gura.

Gura executes programs in the form of a syntax tree. While this is easy to implement, it is difficult to achieve high execution performance. Another problem was that the execution context was tied to C++. For example, a function call within a Gura program would internally use C++'s function call mechanism. This consumed the limited stack memory area allocated by the C++ compiler, quickly leading to stack overflow during recursive calls.

Gurax solved this problem by implementing a dedicated Virtual Machine (VM) that executes custom instruction codes. I prepared instructions for data management, arithmetic, program branching, and jumping, and the script program is now compiled into a sequence of these instructions. This improved performance by about two times compared to Gura. But what made me happiest was that recursive calls no longer caused stack overflow. Since the function call mechanism is handled on the VM, stack management is also independent, and I finally felt liberated from the constraints of C++.

While Gurax is Gura's successor, it was almost built from scratch. Gura's development involved adding features to existing code, which resulted in many inefficient implementations. During the redesign, I also changed the naming convention for the language's provided APIs from snake_case to camelCase. Gura was heavily influenced by the Python implementation, and its function naming followed suit. The use of snake_case was due to that influence, but since I use camelCase in my daily development, the motivation was simply to be honest with my own preference.

---

8. Have you seen other people or projects using Gura-lang outside your own tools, such as Gura Shot or Getter Photo?

I have not heard of anyone else creating programs with Gura. That is quite disappointing.

Yes, Gura Shot! I am very happy you mentioned that. Gura Shot was an application created to demonstrate that the Gura language could be used in practical projects, and I also hoped it would introduce the Gura programming language to many people.

Gura Shot was actually featured on a major Japanese free software site and became a popular hit used by many. It was also listed in many free software magazines, and I believe the download numbers were quite high. I haven't checked the specific access numbers, so I cannot provide figures here. However, despite the application's popularity, no one showed interest in the scripting language that powered it. The Gura Shot program was distributed as plain text Gura script files, meaning the program was fully readable with just a text editor. But since it's an application, it's perfectly natural for people to just use it conveniently for its intended purpose.

While it did not achieve the goal of raising language awareness, the fact that the application was widely accepted proved that the Gura language has the versatility to support such programs. This was a sufficiently satisfying result.

---

9. Developing a programming language alone is a long and complex process. What keeps you motivated to continue this path?

Anyone who programs as a hobby would likely be interested in developing a programming language or an Operating System. While programming languages and OSes greatly assist programming activities, in exchange, the programmer must follow the rules they set. Over time, the desire to create those rules to one's own liking grows and becomes the motivation for development.

However, while I see articles and blogs about self-made programming languages, most of them remain experimental, performing only very basic processing. Once the core parts like the parser, instruction generation, and data management are created, the urge to "create a language" is often satisfied, so this is perhaps inevitable. But I did not want my language to be like that. I believe a programming language is a means to solve a problem, and unless it is elevated to a level where it can solve real-world problems, it cannot be called a true programming language.

To achieve that, I must develop libraries for network processing (HTTP, Sockets), text data processing (Regular Expressions, YAML, XML, JSON), image data processing (JPEG, PNG), and user-interactive processing (GUI). This is a very time-consuming and labor-intensive process.

However, I genuinely enjoy creating these elements. It is fun to see the capabilities of my self-made language increase. I believe I have been driven by the pleasure of knowing that by using my hands and mind, I can continuously increase my assets.

---

10. Finally, what would you like to see happen with Gura-lang (or Gurax) in the future?

Since I have only been driven by my own interest, I honestly don't have a rigid vision for the future. The desire for others to use it is no longer as intense as it once was; I had come to think it would be fine if only I could use it conveniently. Scripting languages are very convenient for quick data processing, and I use Gurax, Gura's successor, daily for my personal work. Therefore, if a feature is needed for my tasks, I will improve the functionality as necessary. ...What a minor and self-contained mindset!

However, that was my stance until yesterday, but through this interview, my way of thinking has changed. I learned that even without aggressive promotion, there are people like you who show interest. Imagining that there might be others who find this project interesting makes a big difference in my approach. Applications such as parallel computing, which would be difficult to achieve with my brain alone, might even become a reality. Therefore, I would like to continue developing Gurax while being open to contributions from others. If anyone is interested in participating in the development, I would be delighted to collaborate.
